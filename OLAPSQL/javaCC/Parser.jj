//set path =( $HOME/javacc2.1/bin $path)
options {

	IGNORE_CASE = true;
	/* pour la trace -->/*
	DEBUG_PARSER=false;
	DEBUG_LOOKAHEAD=false;
	DEBUG_TOKEN_MANAGER = false;
	/**/
	OPTIMIZE_TOKEN_MANAGER=true;
	BUILD_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Analyzer)
package javaCC;
import structure.*;
import structure.types.*;
import structure.types.predicat.*;
import java.util.ArrayList;
import java.sql.Date;
	public class Analyzer{ 
		public Commande c;
	}
PARSER_END(Analyzer)


SKIP:
{" " | "\r" | "\n" | "\t"}


TOKEN:
{
	<CREATE		: "create">
   |	<DROP		: "drop">
   |	<ADD		: "add">
   |	<ALTER		: "alter">
   |	<INSERT		: "insert into">
   |	<DELETE		: "delete from">
   |	<VALUES		: "values">
   |	<SELECT		: "select">
 
   |	<FACT		: "fact">
   |	<LEVEL		: "level">
   |	<WITH		: "with">
   |	<HIERARCHY	: "hierarchy">
   |	<DIMENSION	: "dimension">
   |	<ROW		: "row">
   |	<COLUMN		: "column">
   
   |	<CONNECT	: "connect">
   |	<DISCONNECT	: "disconnect">
   |	<TO		: "to">
   |	<WHERE		: "where">
   |	<FROM		: "from">
   |	<AND		: "and">
   |	<OR		: "or">
// types
   |	<DATE		: "date">
   |	<VARCHAR	: "varchar">
   |	<NUMBER		: "number">
 	//type indetermine
 //  |	<VALEUR		: (["A"-"Z"]|["0"-"9"]|"_"|"/"|"-")*>
   //doit commencer par une lettre
   |	<NOM		: (["A"-"Z"])+(["A"-"Z"]|["0"-"9"]|"_"|".")*>
   |    <CHIFFRE	: (["0"-"9"])+>
//   |    <ENTREQUOT	: >
//symboles
    |	<OUVRANTE	: "(">
    |	<FERMANTE	: ")">
    |	<PTVIRG		: ";">
    |	<PT			: ".">
    |	<VIRG		: ",">
    |	<QUOT		: "'">
    |	<SLASH		: "/">       
//predicats	
/*	|	<EGAL		: "=">
	|	<NEGAL		: "<>">
	|	<SUP		: ">">
	|	<SUPEGAL	: ">=">
	|	<INF		: "<">
	|	<INFEGAL	: "<=">*/
	|	<OPERATOR	: ("="|"<>"|">"|">="|"<"|"<=")>
	|	<FONCT		: "AVG"|"COUNT"|"SUM"|"MAX"|"MIN">
}

/*----------------------------------
-	MAIN
-----------------------------------*/
Commande execute():{}{
	{Commande c=null;}
	
	(	c=create()
	|	c= drop()
	|	c= alter()
	|	c=insert()
	|	c=delete()
	//|	select()*/)
	)
	{ return c;}
}

Predicat executePredicat():{}{
	{return def_pred();}
}

/*----------------------------------
-	COMMANDES
-----------------------------------*/
	/*-------------
	-	CREATE -OK
	---------------*/
Create create():{}{
	{Create c;}
	<CREATE>(c=create_fact() | c=create_dim())
	{return c;}
}
CreateFact create_fact():
{}
{
	{ArrayList l, ll = new ArrayList(); Token t;}
	<FACT>t=<NOM>
	<OUVRANTE>
		l=def_attr()
		{CreateFact cf = new CreateFact(t.toString(), Commande.FACT,l);}
	<FERMANTE>
	<CONNECT><TO>t=<NOM> {ll.add(t.toString());}
				(<VIRG>t=<NOM>{ll.add(t.toString());})*
	<PTVIRG>
	{cf.addConnections(ll);return cf;}
}

CreateDimension create_dim():
{}
{
	{ArrayList l, lhs; Token t;Hierarchy h;}
	<DIMENSION>t=<NOM>
	<OUVRANTE>
		l=def_attr()
		{CreateDimension cd = new CreateDimension(t.toString(), Commande.DIMENSION,l);}
	<FERMANTE>
	(<WITH><HIERARCHY>t= <NOM> 
		<OUVRANTE>
			l = def_lev(){h= new Hierarchy (t.toString(), l);}
		<FERMANTE>
		{cd.ajoutHierarchy(h);}
	)*
	<PTVIRG>
	{return cd;}
}

	/*-------------
	-	DROP	-ok
	---------------*/
Drop drop():{}{
	{Drop d =null;}
	<DROP>( d=drop_fact()| d=drop_dim())
	{return d;}
}
Drop drop_fact():
{}
{
	{Token t;}
	<FACT>t=<NOM><PTVIRG>
	{return new Drop(t.toString(), Commande.FACT);}
}
Drop drop_dim():
{}
{	{Token t;}
	<DIMENSION>t=<NOM><PTVIRG>
	{return new Drop(t.toString(), Commande.DIMENSION);}
}

	/*-------------
	-	ALTER	-OK a ameliorer sur alter_fact
	---------------*/
Alter alter():{}{
	{Alter ca = null;}
	<ALTER>(ca=alter_fact()|ca=alter_dim())
	{return ca;}
}
Alter alter_fact():{}
{
	{Token t; ArrayList l;}
	<FACT>t= <NOM>{ Alter ca = new Alter (t.toString(), Commande.FACT);}
	(
		<ADD> l=def_attr(){ca.setAlteration(Alter.ADD);
							ca.setAttributs(l);}
							
	|	<DROP> t=<NOM> {ca.setAlteration(Alter.DROP);
						ca.ajoutString(t.toString());}
				(<VIRG>t=<NOM>{ca.ajoutString(t.toString());})*
				
	|	<CONNECT><TO> t=<NOM> {ca.setAlteration(Alter.CONNECT);
								ca.ajoutString(t.toString());}
				(<VIRG>t=<NOM>{ca.ajoutString(t.toString());})*
				
	|	<DISCONNECT><TO> t=<NOM> {ca.setAlteration(Alter.DISCONNECT);
									ca.ajoutString(t.toString());}
				(<VIRG>t=<NOM>{ca.ajoutString(t.toString());})*
	)?
	<PTVIRG>
	{return ca;}
}

Alter alter_dim():{}
{
	{Token t; ArrayList l; Alter ca=null;}
	<DIMENSION>t=<NOM>
	(
		<ADD> (  l=def_attr() {ca = new Alter(t.toString(), Commande.DIMENSION,Alter.ADD, l);}
			|	({ca = new AlterHierarchy (t.toString(), Commande.DIMENSION,AlterHierarchy.ADD_HIERARCHY);}
				<HIERARCHY> t= <NOM> 
					<OUVRANTE>
						l = def_lev(){Hierarchy h= new Hierarchy (t.toString(), l);}
					<FERMANTE>
				{((AlterHierarchy)ca).ajoutHierarchy(h);}
				))
	|	<DROP> ({ca = new Alter(t.toString(), Commande.DIMENSION,Alter.DROP);} 
				t=<NOM> {ca.ajoutString(t.toString());}
					(<VIRG>t=<NOM>{ca.ajoutString(t.toString());})*
			|	({ca = new AlterHierarchy (t.toString(), Commande.DIMENSION,AlterHierarchy.DROP_HIERARCHY);}
				<HIERARCHY> t= <NOM>
					{((AlterHierarchy)ca).ajoutHierarchy(new Hierarchy(t.toString(),null));}
				))
	)?
	<PTVIRG>
	{return ca;}
}	

	/*-------------
	-	INSERT
	---------------*/
Insert insert():{}{
	{Insert ci;}
	<INSERT>(ci=insert_fact()|ci=insert_dim())
	{return ci;}
}
InsertFact insert_fact():{}
{
	<FACT> <NOM>
	<VALUES> <OUVRANTE>
			def_une_valeur() (<VIRG>def_une_valeur())* 
		<FERMANTE>
	<CONNECT><TO>
		 <NOM> <WHERE> def_pred()
		(<VIRG><NOM><WHERE> def_pred())*
	<PTVIRG>
	{return null;}
}
Insert insert_dim():{}
{
	{Token t;String s;}
	<DIMENSION>t=<NOM> {Insert ci = new Insert (t.toString(), Commande.DIMENSION);}
	<VALUES><OUVRANTE>
			s=def_une_valeur() {ci.ajoutValeur(s);}
				(<VIRG>s=def_une_valeur(){ci.ajoutValeur(s);})*  
			<FERMANTE>
	<PTVIRG>
	{return ci;}
}

	/*-------------
	-	DELETE -ajouter pred
	---------------*/
Delete delete():{}{
	{Delete d;}
	<DELETE>(d=del_fact()|d=del_dim())
	{return d;}
}
Delete del_fact():{}
{
	{Token t;}
	<FACT>t=<NOM>
	(<WHERE> def_pred())?
	<PTVIRG>
	{return new Delete(t.toString(), Commande.FACT);}
}
Delete del_dim():{}
{
	{Token t;}
	<DIMENSION>t=<NOM>
	(<WHERE> def_pred())?
	<PTVIRG>
	{return new Delete(t.toString(), Commande.DIMENSION);}
}

	/*-------------
	-	SELECT
	---------------*/
void select():{}
{
	<SELECT> def_aggr()
	<ROW> <NOM>
		(<WITH> <NOM>
				(<OUVRANTE>
			<NOM>(<PT><NOM>)? (<VIRG><NOM>(<PT><NOM>)? )* 
				<FERMANTE>)*	
		)?
	<COLUMN> <NOM>
		(<WITH> <NOM>
				(<OUVRANTE>
			<NOM>(<PT><NOM>)? (<VIRG><NOM>(<PT><NOM>)? )* 
				<FERMANTE>)*	
		)?		
	<FROM><NOM>
		(<WHERE> def_pred())?
	<PTVIRG>
}

/*----------------------------------
-	DEFINITIONS
-----------------------------------*/
//tdate renvoit une string, le prend comme token
String def_une_valeur():{}
{
		{Token t=null;String s="";}
		
		<QUOT> (	s=tdate() 
				| 	(		(t=<NOM> {s = s+t.toString();})
						(t=<NOM> {s = s+" "+t.toString();})*
					)
				)								
		<QUOT>	{return s;}
		
	|	t=<CHIFFRE>{return t.toString();}		
}


//pour l'instant pas de parentheses ni or gérés
Predicat def_pred():{}
{
	{Predicat p=new Predicat ();; ElementAbstrait elmt;}
	
		elmt = def_elmt(null)
		
		//commun aux 2
	 	{	p.setRacine(elmt);
	 		return p;}
}

//pas encore ok
ElementAbstrait def_elmt(Liaison pere):{}{	
	{ElementAbstrait expr; Jointure j=null;
		Liaison l;}

	((<OUVRANTE>expr = def_elmt(pere)<FERMANTE>)

|	(
	 expr = def_jointure(pere)	
	((	<AND> {l = new Liaison (pere, Liaison.AND,expr);}
			(	(<OUVRANTE>expr = def_elmt(pere)<FERMANTE> {l.ajoutElmt(expr);
															expr.setPere(l);})
			|	(j = def_jointure(l)	{l.ajoutElmt(j);
										j.setPere(l);}))
			(<AND>	
				(	(<OUVRANTE>expr = def_elmt(pere)<FERMANTE> {l.ajoutElmt(expr);
															expr.setPere(l);})
			|	(j = def_jointure(l)	{l.ajoutElmt(j);
										j.setPere(l);}))
			)*
		)
	 ){expr=l;}
	))
	 {return expr;}
}

//ok
Jointure def_jointure(Liaison pere):{}{
	{Token t1, t2, t3; String s1="",s2="";}
	
	t1=<NOM> {s1=t1.toString();}(<PT>t1=<NOM>{s1=s1+"."+t1.toString();})? 
	t3=<OPERATOR>
			((t2=<NOM> {s2=t2.toString();}(<PT>t2=<NOM>{s2=s2+"."+t2.toString();})? 
				| (s2=def_une_valeur())))
	{return new Jointure(pere,s1,s2,t3.toString());}

}

//AVG, SUM, MAX, COUNT, SOM
void def_aggr():{}
{
	<FONCT> <OUVRANTE>
			<NOM>(<PT><NOM>)?
			<FERMANTE>
	(<VIRG><FONCT> <OUVRANTE>
			<NOM>(<PT><NOM>)?
			<FERMANTE>)*
}

/*renvoit une ArrayList d'attributs*/
//ok
ArrayList def_attr():{}
{
	{Token t; Attribut att;
	ArrayList l=new ArrayList();}
	
	t=<NOM> att=def_dom()
		{	att.setNom(t.toString());
			l.add(att);}
	 (<VIRG> t=<NOM> att=def_dom()
	 	{	att.setNom(t.toString());
			l.add(att);}
	 )*
	 {return l;}
}

/*renvoit un attribut typé mais sans nom*/
//ok
Attribut def_dom():{}
{
	{Attribut att=null;Token t;}
	(<DATE>{att = new Attribut(Attribut.DATE);}
	|	<NUMBER> <OUVRANTE>
				t=<CHIFFRE>{att = new Attribut(Attribut.NUMBER,Integer.parseInt(t.toString()));}
							(<VIRG> t=<CHIFFRE>{att.setPrecision(Integer.parseInt(t.toString()));})?
				<FERMANTE>
	|	<VARCHAR><OUVRANTE>
					t=<CHIFFRE>{att = new Attribut(Attribut.VARCHAR, Integer.parseInt(t.toString()));}
				<FERMANTE>)
	{return att;}
}

//ArrayList de levels
//ok
ArrayList def_lev():{}
{	
	{ArrayList l = new ArrayList(); Token t;Level level;}
	(
	<LEVEL> t=<NOM>{level = new Level(t.toString());}
		(<OUVRANTE>
			t=<NOM> {level.ajoutAttFaible(t.toString());}
			(<VIRG> t=<NOM>{level.ajoutAttFaible(t.toString());})*
		<FERMANTE>)?
		{l.add(level);}
	)+
	{return l;}
}

/*----------------------------------
-	TYPES 
-----------------------------------*/
//pour l'instant, retourne une string
String tdate ():{}
{
	{String dat=""; Token t;}
	t=<CHIFFRE>{dat= t.toString();}
	<SLASH>t=<CHIFFRE>{dat=dat+"-"+ t.toString();}
	<SLASH>t=<CHIFFRE>{dat=dat+"-"+ t.toString();}
	{return dat;}
}


